// Copyright 2022 Indoc Research
// 
// Licensed under the EUPL, Version 1.2 or â€“ as soon they
// will be approved by the European Commission - subsequent
// versions of the EUPL (the "Licence");
// You may not use this work except in compliance with the
// Licence.
// You may obtain a copy of the Licence at:
// 
// https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
// 
// Unless required by applicable law or agreed to in
// writing, software distributed under the Licence is
// distributed on an "AS IS" basis,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied.
// See the Licence for the specific language governing
// permissions and limitations under the Licence.
// 

import { v4 as uuidv4 } from 'uuid';
import { CancelTokenSource } from 'axios';
import _ from 'lodash';

/**
 * this class is to keep track of axios cancel source and we can cancel them later
 */
class AxiosCancelManager {
    constructor() {
        /**
         * @type {{sourceId:string,cancelSource:CancelTokenSource}[]}
         */
        this._cancelSources = [];
    }

    /**
     * add a cancel source, so that all axios request can be cancelled at the same time
     * @param {CancelTokenSource} cancelSource the axios cancel source with a cancel method to cancel tha axios request
     * @returns {string} a id to keep track of this cancel source
     */
    addCancelSource(cancelSource) {
        if (!_.isFunction(cancelSource?.cancel)) {
            throw new TypeError(`addCancelSource should take in axios cancel source as parameter`)
        }
        const sourceId = uuidv4();
        this._cancelSources.push({ sourceId, cancelSource });
        return sourceId;
    }

    /**
     * remove the axios cancel source once the request finish(either success or error). so, please DO remember to call this on axios promise .finally()
     * @param {string} sourceId the corresponding cancel source id generated by addCancelSource
     * @returns {boolean} if the removal succeeds or not
     */
    removeCancelSource(sourceId) {
        if (!_.isString(sourceId)) {
            throw new TypeError(`sourceId should be a string`)
        }
        const removedArr = _.remove(this._cancelSources, (item) => item === sourceId);
        return removedArr.length !== 0;
    }

    /**
     * cancel a single axios request
     * @param {string} sourceId the corresponding cancel source id generated by addCancelSource
     * @returns {boolean} whether the axios request is cancel and the source is removed
     */
    cancelAxios(sourceId) {
        if (!_.isString(sourceId)) {
            throw new TypeError(`sourceId should be a string`)
        }
        /**
         * @type {{sourceId:string,cancelSource:CancelTokenSource}}
         */
        const item = _.find(this._cancelSources,(item)=>item.sourceId===sourceId);
        if(!item){
            return false;
        }else{
            _.isFunction(item.cancelSource.cancel)&&item.cancelSource.cancel();
            return this.removeCancelSource(sourceId);
        }
    }

    /**
     * cancel all axios request
     */
    cancelAllAxios(){
        this._cancelSources.forEach(item=>{
            _.isFunction(item.cancelSource.cancel)&&item.cancelSource.cancel();
        });
        this._cancelSources = [];
    }
}

const axiosCancelManager = new AxiosCancelManager();

export {axiosCancelManager};